#   _________ __               .__                              
#  /   _____//  |______ _______|  | _____    ____   ____  ____  
#  \_____  \\   __\__  \\_  __ \  | \__  \  /    \_/ ___\/ __ \ 
#  /        \|  |  / __ \|  | \/  |__/ __ \|   |  \  \__\  ___/ 
# /_______  /|__| (____  /__|  |____(____  /___|  /\___  >___  >
#         \/           \/                \/     \/     \/    \/ 
# (c) 2026 Pl7y.com

extends WorldObject
class_name Enemy

@export var hp: int = 30
@export var hit_radius_px: float = 18.0

# Shooting
@export var bullet_scene: PackedScene
@export var fire_interval: float = 1.2
@export var fire_min_z: float = 18.0
@export var fire_max_z: float = 95.0
@export var bullet_speed: float = 90.0
@export var aim_lead_y: float = 0.0

## Movement strategy (set by EnemySpawner at spawn time).
var movement_strategy: MovementStrategy = null

@onready var sprite := %Sprite2D

@export var explosion_scene: PackedScene

@onready var _label = %Label as Label

var _fire_t: float = 0.0

func _ready() -> void:
  super._ready()
  add_to_group("enemies")
  _fire_t = randf_range(0.0, fire_interval)

  # Initialize movement strategy if set
  if movement_strategy != null:
    movement_strategy.setup(self, rig)
  
  # Connect to escape signal
  escaped.connect(_on_enemy_escaped)


func _on_enemy_escaped(escape_type: WorldObject.EscapeType) -> void:
  # Handle enemy escape - you can add game logic here
  match escape_type:
    WorldObject.EscapeType.BEHIND_CAMERA:
      print("Enemy escaped behind camera")
    WorldObject.EscapeType.OFF_SCREEN_LEFT:
      print("Enemy escaped left")
    WorldObject.EscapeType.OFF_SCREEN_RIGHT:
      print("Enemy escaped right")
    WorldObject.EscapeType.TOO_FAR_AHEAD:
      print("Enemy escaped ahead")
  
  # Example: Notify a game manager, increment escaped counter, etc.
  # if has_node("/root/GameManager"):
  #   get_node("/root/GameManager").on_enemy_escaped(escape_type)

func configure(p_hp: int, p_fire_interval: float, p_bullet_speed: float) -> void:
  hp = p_hp
  fire_interval = p_fire_interval
  bullet_speed = p_bullet_speed

func _process(delta: float) -> void:
  _update_movement(delta)

  # Set label text to world_pos, rounded to first digit
  _label.text = "Pos: (%.1f, %.1f, %.1f)" % [world_pos.x, world_pos.y, world_pos.z]

  # Project + place sprite
  super._process(delta)

  # Shooting (unchanged, but uses current world_pos)
  _try_shoot(delta)

func _update_movement(delta: float) -> void:
  if rig == null:
    return

  match pattern:
    MovePattern.STATIC:
      # no-op
      pass

    MovePattern.DRIFT:
      world_pos.x += speed_x * delta
      world_pos.y += speed_y * delta
      world_pos.z += speed_z * delta

    MovePattern.SINE_STRAFE:
      # Moves forward/back via speed_z, with sinusoidal x (and optional y)
      world_pos.z += speed_z * delta
      world_pos.x = _spawn_pos.x + sin(_age * TAU * freq) * amp_x
      world_pos.y = _spawn_pos.y + sin(_age * TAU * (freq * 0.7)) * amp_y

    MovePattern.DIVE_AT_PLAYER:
      # Smoothly home towards camera X/Y while advancing in Z
      world_pos.z += speed_z * delta

      var target_x := rig.camera_world_position.x
      var target_y := rig.camera_world_position.y
      world_pos.x = lerp(world_pos.x, target_x, 1.0 - exp(-dive_turn * delta))
      world_pos.y = lerp(world_pos.y, target_y, 1.0 - exp(-dive_turn * delta))

    MovePattern.SWOOP:
      # A readable “arc”: starts offset, crosses center, exits
      world_pos.z += speed_z * delta
      world_pos.x = _spawn_pos.x + sin(_age * TAU * freq) * amp_x
      world_pos.y = _spawn_pos.y + cos(_age * TAU * freq) * amp_y

    MovePattern.ORBIT:
      # Orbits around a point in front of camera (feels 3D-ish even in fake 3D)
      world_pos.z += speed_z * delta
      _orbit_angle += orbit_speed * delta
      var cx := rig.camera_world_position.x
      var cy := rig.camera_world_position.y
      world_pos.x = cx + cos(_orbit_angle) * orbit_radius
      world_pos.y = cy + sin(_orbit_angle) * (orbit_radius * 0.6)

    MovePattern.RUSH_FOLLOW:
      # Phase 1: Rush toward a point `follow_distance` ahead of camera.
      # Phase 2: Once arrived, orbit at that distance like an escort.
      var target_z := rig.camera_world_position.z - follow_distance
      var target_x := rig.camera_world_position.x
      var target_y := rig.camera_world_position.y

      if not _rush_arrived:
        # Approach phase — fast homing toward the lock-on point
        world_pos.z = lerp(world_pos.z, target_z, 1.0 - exp(-rush_turn * delta))
        world_pos.x = lerp(world_pos.x, target_x, 1.0 - exp(-rush_turn * delta))
        world_pos.y = lerp(world_pos.y, target_y, 1.0 - exp(-rush_turn * delta))

        # Check if close enough to transition
        var dist_sq := (world_pos - Vector3(target_x, target_y, target_z)).length_squared()
        if dist_sq < 4.0: # within ~2 world units
          _rush_arrived = true
      else:
        # Follow phase — orbit around the player at fixed Z offset
        _orbit_angle += orbit_speed * delta
        world_pos.z = lerp(world_pos.z, target_z, 1.0 - exp(-2.0 * delta)) # gently track Z
        world_pos.x = target_x + cos(_orbit_angle) * orbit_radius
        world_pos.y = target_y + sin(_orbit_angle) * (orbit_radius * 0.6)

    MovePattern.CUSTOM:
      if custom_move_logic != null:
        custom_move_logic.update(self , rig, delta)

func _try_shoot(delta: float) -> void:
  if rig == null or bullet_scene == null:
    return

  _fire_t -= delta
  if _fire_t > 0.0:
    return

  # Check depth (distance from camera) - negative z is ahead
  var rel_z := world_pos.z - rig.camera_world_position.z
  var depth := -rel_z
  if depth < fire_min_z or depth > fire_max_z:
    return

  _fire_t = fire_interval
  _fire()

func _fire() -> void:
  var b := bullet_scene.instantiate() as EnemyBullet
  get_parent().add_child(b)

  b.world_pos = world_pos

  # Target slightly ahead of camera (negative z is ahead)
  var target := Vector3(rig.camera_world_position.x, rig.camera_world_position.y + aim_lead_y, rig.camera_world_position.z - 10.0)
  var dir := target - b.world_pos
  if dir.length() < 0.001:
    dir = Vector3(0, 0, 1) # Default: toward positive z (toward camera)
  dir = dir.normalized()
  b.vel_direction = dir
  b.vel = dir * bullet_speed

func take_hit(dmg: int) -> void:
  _flash_white()

  var explosion: Explosion = explosion_scene.instantiate()
  explosion.world_pos = world_pos

  hp -= dmg
  
  if hp <= 0:
    get_parent().add_child(explosion)
    queue_free()
  else:
    add_child(explosion)
    
func _flash_white() -> void:
  # Flash white on hit
  if sprite != null:
    sprite.modulate = Color("ff0000")
    get_tree().create_timer(0.1).timeout.connect(func(): sprite.modulate = Color(1, 1, 1, 1))


func _on_hurt_box_area_entered(_area: Area3D) -> void:
  var player = _area.get_parent() as Player
  if player:
    return

  var bullet = _area.get_parent() as Bullet
  if bullet:
    take_hit(bullet.damage)
    bullet.queue_free()
